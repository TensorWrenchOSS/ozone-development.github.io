<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>app/js/client/client.js - ozpIwc</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="ozpIwc"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.2.2</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/ozpIwc.ApiError.html">ozpIwc.ApiError</a></li>
            
                <li><a href="../classes/ozpIwc.AsyncAction.html">ozpIwc.AsyncAction</a></li>
            
                <li><a href="../classes/ozpIwc.CancelableEvent.html">ozpIwc.CancelableEvent</a></li>
            
                <li><a href="../classes/ozpIwc.Client.html">ozpIwc.Client</a></li>
            
                <li><a href="../classes/ozpIwc.CommonApiBase.html">ozpIwc.CommonApiBase</a></li>
            
                <li><a href="../classes/ozpIwc.CommonApiCollectionValue.html">ozpIwc.CommonApiCollectionValue</a></li>
            
                <li><a href="../classes/ozpIwc.CommonApiValue.html">ozpIwc.CommonApiValue</a></li>
            
                <li><a href="../classes/ozpIwc.DataApi.html">ozpIwc.DataApi</a></li>
            
                <li><a href="../classes/ozpIwc.DataApiValue.html">ozpIwc.DataApiValue</a></li>
            
                <li><a href="../classes/ozpIwc.Endpoint.html">ozpIwc.Endpoint</a></li>
            
                <li><a href="../classes/ozpIwc.EndpointRegistry.html">ozpIwc.EndpointRegistry</a></li>
            
                <li><a href="../classes/ozpIwc.Event.html">ozpIwc.Event</a></li>
            
                <li><a href="../classes/ozpIwc.FragmentPacket.html">ozpIwc.FragmentPacket</a></li>
            
                <li><a href="../classes/ozpIwc.FragmentStore.html">ozpIwc.FragmentStore</a></li>
            
                <li><a href="../classes/ozpIwc.IntentsApi.html">ozpIwc.IntentsApi</a></li>
            
                <li><a href="../classes/ozpIwc.IntentsApiDefinitionValue.html">ozpIwc.IntentsApiDefinitionValue</a></li>
            
                <li><a href="../classes/ozpIwc.IntentsApiHandlerValue.html">ozpIwc.IntentsApiHandlerValue</a></li>
            
                <li><a href="../classes/ozpIwc.IntentsApiTypeValue.html">ozpIwc.IntentsApiTypeValue</a></li>
            
                <li><a href="../classes/ozpIwc.InternalParticipant.html">ozpIwc.InternalParticipant</a></li>
            
                <li><a href="../classes/ozpIwc.KeyBroadcastLocalStorageLink.html">ozpIwc.KeyBroadcastLocalStorageLink</a></li>
            
                <li><a href="../classes/ozpIwc.LeaderGroupParticipant.html">ozpIwc.LeaderGroupParticipant</a></li>
            
                <li><a href="../classes/ozpIwc.LocalStorageLink.html">ozpIwc.LocalStorageLink</a></li>
            
                <li><a href="../classes/ozpIwc.log.html">ozpIwc.log</a></li>
            
                <li><a href="../classes/ozpIwc.MetricsRegistry.html">ozpIwc.MetricsRegistry</a></li>
            
                <li><a href="../classes/ozpIwc.metricsStats.Sample.html">ozpIwc.metricsStats.Sample</a></li>
            
                <li><a href="../classes/ozpIwc.metricsStats.UniformSample.html">ozpIwc.metricsStats.UniformSample</a></li>
            
                <li><a href="../classes/ozpIwc.metricStats.html">ozpIwc.metricStats</a></li>
            
                <li><a href="../classes/ozpIwc.metricStats.BinaryHeap.html">ozpIwc.metricStats.BinaryHeap</a></li>
            
                <li><a href="../classes/ozpIwc.metricStats.ExponentiallyDecayingSample.html">ozpIwc.metricStats.ExponentiallyDecayingSample</a></li>
            
                <li><a href="../classes/ozpIwc.metricTypes.BaseMetric.html">ozpIwc.metricTypes.BaseMetric</a></li>
            
                <li><a href="../classes/ozpIwc.metricTypes.Counter.html">ozpIwc.metricTypes.Counter</a></li>
            
                <li><a href="../classes/ozpIwc.metricTypes.Gauge.html">ozpIwc.metricTypes.Gauge</a></li>
            
                <li><a href="../classes/ozpIwc.metricTypes.Histogram.html">ozpIwc.metricTypes.Histogram</a></li>
            
                <li><a href="../classes/ozpIwc.metricTypes.Meter.html">ozpIwc.metricTypes.Meter</a></li>
            
                <li><a href="../classes/ozpIwc.MulticastParticipant.html">ozpIwc.MulticastParticipant</a></li>
            
                <li><a href="../classes/ozpIwc.NamesApi.html">ozpIwc.NamesApi</a></li>
            
                <li><a href="../classes/ozpIwc.NamesApiValue.html">ozpIwc.NamesApiValue</a></li>
            
                <li><a href="../classes/ozpIwc.NetworkPacket.html">ozpIwc.NetworkPacket</a></li>
            
                <li><a href="../classes/ozpIwc.Participant.html">ozpIwc.Participant</a></li>
            
                <li><a href="../classes/ozpIwc.Peer.html">ozpIwc.Peer</a></li>
            
                <li><a href="../classes/ozpIwc.policyAuth.PDP.html">ozpIwc.policyAuth.PDP</a></li>
            
                <li><a href="../classes/ozpIwc.policyAuth.SecurityAttribute.html">ozpIwc.policyAuth.SecurityAttribute</a></li>
            
                <li><a href="../classes/ozpIwc.PostMessageParticipant.html">ozpIwc.PostMessageParticipant</a></li>
            
                <li><a href="../classes/ozpIwc.PostMessageParticipantListener.html">ozpIwc.PostMessageParticipantListener</a></li>
            
                <li><a href="../classes/ozpIwc.Router.html">ozpIwc.Router</a></li>
            
                <li><a href="../classes/ozpIwc.RouterWatchdog.html">ozpIwc.RouterWatchdog</a></li>
            
                <li><a href="../classes/ozpIwc.SystemApi.html">ozpIwc.SystemApi</a></li>
            
                <li><a href="../classes/ozpIwc.SystemApiApplicationValue.html">ozpIwc.SystemApiApplicationValue</a></li>
            
                <li><a href="../classes/ozpIwc.Timer.html">ozpIwc.Timer</a></li>
            
                <li><a href="../classes/ozpIwc.TransportPacket.html">ozpIwc.TransportPacket</a></li>
            
                <li><a href="../classes/ozpIwc.TransportPacketContext.html">ozpIwc.TransportPacketContext</a></li>
            
                <li><a href="../classes/ozpIwc.util.html">ozpIwc.util</a></li>
            
                <li><a href="../classes/ozpIwcPolicies.html">ozpIwcPolicies</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/bus.html">bus</a></li>
            
                <li><a href="../modules/bus.api.html">bus.api</a></li>
            
                <li><a href="../modules/bus.api.Type.html">bus.api.Type</a></li>
            
                <li><a href="../modules/bus.api.Value.html">bus.api.Value</a></li>
            
                <li><a href="../modules/bus.network.html">bus.network</a></li>
            
                <li><a href="../modules/bus.network.packets.html">bus.network.packets</a></li>
            
                <li><a href="../modules/bus.security.html">bus.security</a></li>
            
                <li><a href="../modules/bus.transport.html">bus.transport</a></li>
            
                <li><a href="../modules/bus.util.html">bus.util</a></li>
            
                <li><a href="../modules/client.html">client</a></li>
            
                <li><a href="../modules/common.html">common</a></li>
            
                <li><a href="../modules/metrics.html">metrics</a></li>
            
                <li><a href="../modules/metrics.statistics.html">metrics.statistics</a></li>
            
                <li><a href="../modules/metrics.types.html">metrics.types</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: app/js/client/client.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
var ozpIwc=ozpIwc || {};

/**
 * Client-side functionality of the IWC. This is the API for widget use.
 * @module client
 */

/**
 * This class will be heavily modified in the future.
 * @class Client
 * @namespace ozpIwc
 *
 * @todo accept a list of peer URLs that are searched in order of preference
 * @param {Object} config
 * @param {String} config.peerUrl - Base URL of the peer server
 * @param {Boolean} [config.autoConnect=true] - Whether to automatically find and connect to a peer
 */
ozpIwc.Client=function(config) {
    config=config || {};

    /**
     * The address assigned to this client.
     * @property address
     * @type String
     */
    this.address=&quot;$nobody&quot;;

    /**
     * Key value store of callback functions for the client to act upon when receiving a reply via the IWC.
     * @property promiseCallbacks
     * @type Object
     */
    this.promiseCallbacks={};
    // coerce config.peerUrl to a function
    
    var configUrl=config.peerUrl;
    if(typeof(configUrl) === &quot;string&quot;) {
        this.peerUrlCheck=function(url,resolve) {
            if(typeof url !== &#x27;undefined&#x27;){
                resolve(url);
            } else {
                resolve(configUrl);
            }

        };
    } else if(Array.isArray(configUrl)) {
        this.peerUrlCheck=function(url,resolve) {
            if(configUrl.indexOf(url) &gt;= 0) {
                resolve(url);
            }
            resolve(configUrl[0]);
        };
    } else if(typeof(configUrl) === &quot;function&quot;) {
        /**
         * @property peerUrlCheck
         * @type String
         */
        this.peerUrlCheck=configUrl;
    } else {
        throw new Error(&quot;PeerUrl must be a string, array of strings, or function&quot;);
    }

    /**
     * @property autoConnect
     * @type {Boolean}
     * @default true
     */
    this.autoConnect=(&quot;autoConnect&quot; in config) ? config.autoConnect : true;

    /**
     * @property msgIdSequence
     * @type Number
     * @default 0
     */
    this.msgIdSequence=0;

    /**
     * An events module for the Client
     * @property events
     * @type ozpIwc.Event
     */
    this.events=new ozpIwc.Event();
    this.events.mixinOnOff(this);

    /**
     * @property receivedPackets
     * @type Number
     * @default 0
     */
    this.receivedPackets=0;

    /**
     * @property receivedBytes
     * @type Number
     * @default 0
     */
    this.receivedBytes=0;

    /**
     * @property sentPackets
     * @type Number
     * @default 0
     */
    this.sentPackets=0;

    /**
     * @property sentBytes
     * @type Number
     * @default 0
     */
    this.sentBytes=0;

    /**
     * The epoch time the Client was instantiated.
     * @property startTime
     * @type Number
     */
    this.startTime=ozpIwc.util.now();

    /**
     * @property launchParams
     * @type Object
     * @default {}
     */
    this.launchParams={};
    
    this.readLaunchParams(window.name);
    this.readLaunchParams(window.location.search);
    this.readLaunchParams(window.location.hash);
    
    /**
     * A map of available apis and their actions.
     * @property apiMap
     * @type Object
     */
    this.apiMap= ozpIwc.apiMap || {};

    /**
     * @property wrapperMap
     * @type Object
     * @default {}
     */
    this.wrapperMap={};


    /**
     * @property preconnectionQueue
     * @type Array
     * @default []
     */
    this.preconnectionQueue=[];

    /**
     * @property watchMsgMap
     * @type Object
     * @default {}
     */
    this.watchMsgMap = {};
    this.registeredCallbacks = {};


    /**
     * @property launchedIntents
     * @type Array
     * @default []
     */
    this.launchedIntents = [];

    this.constructApiFunctions();
    if(this.autoConnect) {
        this.connect();
    }


};

/**
 * Parses launch parameters based on the raw string input it receives.
 *
 * @method readLaunchParams
 * @param {String} rawString
 */
ozpIwc.Client.prototype.readLaunchParams=function(rawString) {
    // of the form ozpIwc.VARIABLE=VALUE, where:
    //   VARIABLE is alphanumeric + &quot;_&quot;
    //   VALUE does not contain &amp; or #
    var re=/ozpIwc.(\w+)=([^&amp;#]+)/g;
    var m;
    while((m=re.exec(rawString)) !== null) {
        var params = decodeURIComponent(m[2]);
        try{
            params = JSON.parse(params);
        } catch(e){
            // ignore the errors and just pass through the string
        }
        this.launchParams[m[1]]=params;
    }
};
/**
 * Receive a packet from the connected peer.  If the packet is a reply, then
 * the callback for that reply is invoked.  Otherwise, it fires a receive event
 *
 * Fires:
 *     - {{#crossLink &quot;ozpIwc.Client/receive:event}}{{/crossLink}}
 *
 * @method receive
 * @protected
 * @param {ozpIwc.TransportPacket} packet
 */
ozpIwc.Client.prototype.receive=function(packet) {
    var handled = false;

    //Try and handle this packet as a reply message
    if(packet.src === &quot;$transport&quot; || (packet.replyTo &amp;&amp; this.promiseCallbacks[packet.replyTo])) {

        var replyCancel = false;
        var replyDone=function() {
            replyCancel = true;
        };
        this.promiseCallbacks[packet.replyTo](packet,replyDone);

        if (replyCancel) {
            this.cancelPromiseCallback(packet.replyTo);
            handled = true;
        }

    }

    //Try and handle this packet as callback message
    if(!handled &amp;&amp; packet.replyTo &amp;&amp; this.registeredCallbacks[packet.replyTo]){
        handled = true;

        var registeredCancel = false;
        var registeredDone=function() {
            registeredCancel = true;
        };

        this.registeredCallbacks[packet.replyTo](packet,registeredDone);
        if (registeredCancel) {
            if(this.watchMsgMap[packet.replyTo].action === &quot;watch&quot;) {
                this.api(this.watchMsgMap[packet.replyTo].dst).unwatch(this.watchMsgMap[packet.replyTo].resource);
            }
            this.cancelRegisteredCallback(packet.replyTo);
        }
    }

    // Otherwise trigger &quot;receive&quot; for someone to handle it
    if(!handled){
        /**
         * Fired when the client receives a packet.
         * @event #receive
         */
        this.events.trigger(&quot;receive&quot;,packet);
    }
};
/**
 * Sends a packet through the IWC.
 *
 * @method send
 * @param {String} dst Where to send the packet.
 * @param {Object} entity  The payload of the packet.
 * @param {Function} callback The Callback for any replies. The callback will be persisted if it returns a truth-like
 * value, canceled if it returns a false-like value.
 */
ozpIwc.Client.prototype.send=function(fields,callback,preexistingPromiseRes,preexistingPromiseRej) {
    var promiseRes = preexistingPromiseRes;
    var promiseRej = preexistingPromiseRej;
    var promise =  new Promise(function(resolve,reject){

        if(!promiseRes &amp;&amp; !promiseRej){
            promiseRes = resolve;
            promiseRej = reject;
        }
    });

    if(!(this.isConnected() || fields.dst===&quot;$transport&quot;)) {
        // when send is switched to promises, create the promise first and return it here, as well
        this.preconnectionQueue.push({
            &#x27;fields&#x27;: fields,
            &#x27;callback&#x27;: callback,
            &#x27;promiseRes&#x27;: promiseRes,
            &#x27;promiseRej&#x27;: promiseRej
        });
        return promise;
    }

    var now=new Date().getTime();
    var id=&quot;p:&quot;+this.msgIdSequence++; // makes the code below read better
    var packet={
        ver: 1,
        src: this.address,
        msgId: id,
        time: now
    };

    for(var k in fields) {
        packet[k]=fields[k];
    }

    var self = this;

    if(callback) {
        this.registeredCallbacks[id] = function (reply, done) {
            if(reply.entity &amp;&amp; reply.entity.inFlightIntent) {
                self.intentInvocationHandling(packet.resource,reply.entity.inFlightIntent,callback);
            } else {
                callback(reply, done);
            }
        };
    }

    this.promiseCallbacks[id]=function (reply,done) {
        if (reply.src === &quot;$transport&quot; || /(ok).*/.test(reply.response)) {
            done();
            promiseRes(reply);
        } else if (/(bad|no).*/.test(reply.response)) {
            done();
            promiseRej(reply);
        } else {
            // it was not a promise callback
        }
    };

    ozpIwc.util.safePostMessage(this.peer,packet,&#x27;*&#x27;);
    this.sentBytes+=packet.length;
    this.sentPackets++;

    if(packet.action === &quot;watch&quot;) {
        this.watchMsgMap[id] = packet;
    } else if(packet.action === &quot;unwatch&quot; &amp;&amp; packet.replyTo) {
        this.cancelRegisteredCallback(packet.replyTo);
    }
    return promise;
};

/**
 * Builds the client api calls from the values in client.apiMap
 *
 * @method constructApiFunctions
 */
ozpIwc.Client.prototype.constructApiFunctions = function(){
    for (var api in this.apiMap) {
        var apiObj = this.apiMap[api];
        var apiFuncName = apiObj.address.replace(&#x27;.api&#x27;, &#x27;&#x27;);

        //prevent overriding client constructed fields, but allow updating of constructed APIs
        if (!this.hasOwnProperty(apiFuncName) || this.apiMap[api].functionName === apiFuncName) {
            // wrap this in a function to break the closure
            // on apiObj.address that would otherwise register
            // everything for the last api in the list
            /*jshint loopfunc:true*/
            (function (self,addr) {
                self[apiFuncName] = function () {
                    return self.api(addr);
                };
                self.apiMap[addr] = self.apiMap[addr] || {};
                self.apiMap[addr].functionName = apiFuncName;
                self.updateApi(addr);
            })(this,apiObj.address);
        }
    }
};

/**
 * Calls the names.api to gather the /api/* resources to gain knowledge of available api actions of the current bus.
 *
 * @method gatherApiInformation
 * @returns {Promise}
 */
ozpIwc.Client.prototype.gatherApiInformation = function(){
    var self = this;
    // gather api information
    return this.send({
        dst: &quot;names.api&quot;,
        action: &quot;get&quot;,
        resource: &quot;/api&quot;
    }).then(function(reply){
        if(reply.response === &#x27;ok&#x27;){
            return reply.entity;
        } else {
            throw reply.response;
        }
    }).then(function(apis) {
        var promiseArray = [];
        apis.forEach(function (api) {
            var promise = self.send({
                dst: &quot;names.api&quot;,
                action: &quot;get&quot;,
                resource: api
            }).then(function (res) {
                if (res.response === &#x27;ok&#x27;) {
                    var name = api.replace(&#x27;/api/&#x27;, &#x27;&#x27;);
                    self.apiMap[name] = self.apiMap[name] || {};
                    self.apiMap[name].address =  name;
                    self.apiMap[name].actions = res.entity.actions;
                } else {
                    throw res.response;
                }
            });
            promiseArray.push(promise);
        });
        return Promise.all(promiseArray);
    });
};

/**
 * Returns whether or not the Client is connected to the IWC bus.
 *
 * @method isConnected
 * @returns {Boolean}
 */
ozpIwc.Client.prototype.isConnected=function(){
    return this.address !== &quot;$nobody&quot;;
};

/**
 * Cancel a reply callback registration.
 * @method cancelPromiseCallback
 * @param (String} msgId The packet replyTo ID for which the callback was registered.
 *
 * @return {Boolean} True if the cancel was successful, otherwise false.
 */
ozpIwc.Client.prototype.cancelPromiseCallback=function(msgId) {
    var success=false;
    if (msgId) {
        delete this.promiseCallbacks[msgId];
        success=true;
    }
    return success;
};

/**
 * Cancel a watch callback registration.
 *
 * @method cancelRegisteredCallback
 * @param (String} msgId The packet replyTo ID for which the callback was registered.
 *
 * @return {Boolean} True if the cancel was successful, otherwise false.
 */
ozpIwc.Client.prototype.cancelRegisteredCallback=function(msgId) {
    var success=false;
    if (msgId) {
        delete this.registeredCallbacks[msgId];
        delete this.watchMsgMap[msgId];
        success=true;
    }
    return success;
};

/**
 * Registers callbacks
 *
 * @method on
 * @param {String} event The event to call the callback on.
 * @param {Function} callback The function to be called.
 *
 */
ozpIwc.Client.prototype.on=function(event,callback) {
    if(event===&quot;connected&quot; &amp;&amp; this.isConnected()) {
        callback(this);
        return;
    }
    return this.events.on.apply(this.events,arguments);
};

/**
 * De-registers callbacks
 *
 * @method off
 * @param {String} event The event to call the callback on.
 * @param {Function} callback The function to be called.
 *
 */
ozpIwc.Client.prototype.off=function(event,callback) {
    return this.events.off.apply(this.events,arguments);
};

/**
 * Disconnects the client from the IWC bus.
 *
 * @method disconnect
 */
ozpIwc.Client.prototype.disconnect=function() {
    this.promiseCallbacks={};
    this.registeredCallbacks={};
    window.removeEventListener(&quot;message&quot;,this.postMessageHandler,false);
    if(this.iframe) {
        this.iframe.src = &quot;about:blank&quot;;
        var self = this;
        window.setTimeout(function(){
            document.body.removeChild(self.iframe);
            self.iframe = null;
        },0);
    }
};


/**
 * Connects the client from the IWC bus.
 * Fires:
 *     - {{#crossLink &quot;ozpIwc.Client/#connected&quot;}}{{/crossLink}}
 *
 * @method connect
 */
ozpIwc.Client.prototype.connect=function() {
    if(!this.connectPromise) {
        var self=this;

        /**
         * Promise to chain off of for client connection asynchronous actions.
         * @property connectPromise
         * @type Promise
         */
        this.connectPromise=new Promise(function(resolve) {
            self.peerUrlCheck(self.launchParams.peer,resolve);
        }).then(function(url) {
            // now that we know the url to connect to, find a peer element
            // currently, this is only via creating an iframe.
            self.peerUrl=url;
            self.peerOrigin=ozpIwc.util.determineOrigin(url);
            return self.createIframePeer();
        }).then(function() {
            // start listening to the bus and ask for an address
            this.postMessageHandler = function (event) {
                if (event.origin !== self.peerOrigin) {
                    return;
                }
                try {
                    var message = event.data;
                    if (typeof(message) === &#x27;string&#x27;) {
                        message = JSON.parse(event.data);
                    }
                    self.receive(message);
                    self.receivedBytes += (event.data.length * 2);
                    self.receivedPackets++;
                } catch (e) {
                    // ignore!
                }
            };
            // receive postmessage events
            window.addEventListener(&quot;message&quot;, this.postMessageHandler, false);
            return self.send({dst: &quot;$transport&quot;});
        }).then(function(message) {
            self.address = message.dst;

            /**
             * Fired when the client receives its address.
             * @event #gotAddress
             */
            self.events.trigger(&quot;gotAddress&quot;, self);

            // dump any queued sends, trigger that we are fully connected
            self.preconnectionQueue.forEach(function (p) {
                self.send(p.fields, p.callback, p.promiseRes, p.promiseRej);
            });
            self.preconnectionQueue = null;

            if (!self.launchParams.inFlightIntent) {
                return;
            }

            // fetch the inFlightIntent
            var packet = {
                dst: &quot;intents.api&quot;,
                resource: self.launchParams.inFlightIntent,
                action: &quot;get&quot;
            };
            return self.send(packet);
        }).then(function (response) {
            if(response) {
                self.launchedIntents.push(response);
                if (response.response === &#x27;ok&#x27;) {
                    for (var k in response.entity) {
                        self.launchParams[k] = response.entity[k];
                    }
                }
            }
            /**
             * Fired when the client is connected to the IWC bus.
             * @event #connected
             */
            self.events.trigger(&quot;connected&quot;);
        })[&#x27;catch&#x27;](function(error) {
            ozpIwc.log.log(&quot;Failed to connect to bus &quot;,error);
        });
    }
    return this.connectPromise; 
};

/**
 * Creates an invisible iFrame Peer for IWC bus communication.
 *
 * @method createIframePeer
 */
ozpIwc.Client.prototype.createIframePeer=function() {
    var self=this;
    return new Promise(function(resolve,reject) {
        var createIframeShim=function() {
            self.iframe=document.createElement(&quot;iframe&quot;);
            self.iframe.addEventListener(&quot;load&quot;,function() {
                resolve();
            });
            self.iframe.src=self.peerUrl+&quot;/iframe_peer.html&quot;;
            self.iframe.height=1;
            self.iframe.width=1;
            self.iframe.setAttribute(&quot;area-hidden&quot;,true);
            self.iframe.setAttribute(&quot;hidden&quot;,true);
            self.iframe.style.setProperty (&quot;display&quot;, &quot;none&quot;, &quot;important&quot;);
            document.body.appendChild(self.iframe);
            self.peer=self.iframe.contentWindow;
            

        };
        // need at least the body tag to be loaded, so wait until it&#x27;s loaded
        if(document.readyState === &#x27;complete&#x27; ) {
            createIframeShim();
        } else {
            window.addEventListener(&quot;load&quot;,createIframeShim,false);
        }
    });
};

/**
 * Handles intent invocation packets. Communicates back with the intents.api to operate the in flight intent state
 * machine.
 *
 * @method intentInvocationHandling
 * @param resource {String} The resource of the packet that sent the intent invocation
 * @param intentResource {String} The in flight intent resource, used internally to operate the in flight intent state machine
 * @param callback {Function} The intent handler&#x27;s callback function
 * @returns {Promise}
 */
ozpIwc.Client.prototype.intentInvocationHandling = function(resource,intentResource,callback) {
    var self = this;
    var res;
    return self.send({
        dst: &quot;intents.api&quot;,
        action: &quot;get&quot;,
        resource: intentResource
    }).then(function (response) {
        response.entity.handler = {
            address: self.address,
            resource: resource
        };
        response.entity.state = &quot;running&quot;;

        res = response;
        return self.send({
            dst: &quot;intents.api&quot;,
            contentType: response.contentType,
            action: &quot;set&quot;,
            resource: intentResource,
            entity: response.entity
        });
    }).then(function (reply) {
        //Now run the intent
        res.entity.reply.entity = callback(res.entity) || {};
        // then respond to the inflight resource
        res.entity.state = &quot;complete&quot;;
        res.entity.reply.contentType = res.entity.intent.type;
        return self.send({
            dst: &quot;intents.api&quot;,
            contentType: res.contentType,
            action: &quot;set&quot;,
            resource: intentResource,
            entity: res.entity
        });
    });
};

/**
 * Calls the specific api wrapper given an api name specified.
 * If the wrapper does not exist it is created.
 *
 * @method api
 * @param apiName {String} The name of the api.
 * @returns {Function} returns the wrapper call for the given api.
 */
ozpIwc.Client.prototype.api=function(apiName) {
    return this.wrapperMap[apiName] || this.updateApi(apiName);
};


/**
 * Updates the wrapper map for api use. Whenever functionality is added or removed from the apiMap the
 * updateApi must be called to reflect said changes on the wrapper map.
 *
 * @method updateApi
 * @param apiName {String} The name of the api
 * @returns {Function} returns the wrapper call for the given api.
 */
ozpIwc.Client.prototype.updateApi = function(apiName){
    var augment = function (dst,action,client) {
        return function (resource, fragment, otherCallback) {
            // If a fragment isn&#x27;t supplied argument #2 should be a callback (if supplied)
            if(typeof fragment === &quot;function&quot;){
                otherCallback = fragment;
                fragment = {};
            }
            var packet = {
                &#x27;dst&#x27;: dst,
                &#x27;action&#x27;: action,
                &#x27;resource&#x27;: resource,
                &#x27;entity&#x27;: {}
            };
            for (var k in fragment) {
                packet[k] = fragment[k];
            }
            if(dst === &quot;intents.api&quot; &amp;&amp; action === &quot;register&quot;){
                for(var i in client.launchedIntents){
                    var loadedResource = &#x27;/&#x27; + client.launchedIntents[i].entity.intent.type + &#x27;/&#x27; + client.launchedIntents[i].entity.intent.action;
                    if(resource === loadedResource){
                        client.intentInvocationHandling(resource,client.launchedIntents[i].resource,otherCallback);
                        delete client.launchedIntents[i];
                    }
                }
            }
            return client.send(packet,otherCallback);
        };
    };

    var wrapper=this.wrapperMap[apiName] || {};
    if(this.apiMap.hasOwnProperty(apiName)) {
        var api = this.apiMap[apiName];
        wrapper = {};
        for (var i = 0; i &lt; api.actions.length; ++i) {
            var action = api.actions[i];
            wrapper[action] = augment(api.address, action, this);
        }

        this.wrapperMap[apiName] = wrapper;
    }
    wrapper.apiName=apiName;
    return wrapper;
};
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
